/* A simple scanner for a toy Pascal-like language. */
%option noyywrap
%{
#include <math.h> // for atof() 
#include "tschudnowsky_fu.yy.h" //generated by bison
#include<string.h>
#include<stdio.h>
#define YYSTYPE char const *

int num_lines = 1;
%}
    
DIGIT    [0-9] 
ID       [_a-zA-Z][a-zA-Z_0-9]*
HEX      [A-Fa-f]+

%%  
[\n]      ++num_lines;

"+" return PLUS ;

"*" return  MUL;

"-" return  MINUS;

"/" return  DIV;

"=" return  ASSIGN;

"==" return  EQUAL;

"!=" return  NOT_EQUAL;

"<" return  LT;

"<=" return  LE;

">" return  GT;

">=" return  GE;

"," return  COMMA;

":" return  COLON;

";" return  SEMICOLON;

"(" return  LPARENTHESIS;

")" return  RPARENTHESIS;

"[" return  LBRACKET;

"]" return  RBRACKET;

"{" return  LBRACE;

"}" return  RBRACE;

"&&" return  AND;

"||" return  OR;

"++" return  INC;

"--" return  DEC;

"_" return UNDERSCORE;

true|false return BOOL;

{DIGIT}+"."{DIGIT}*("e"|"E"){DIGIT}+(("lf"|"LF")?|("f"|"F")?)    return FLOAT;

{DIGIT}+"."{DIGIT}*(("lf"|"LF")?|("f"|"F")?)    return FLOAT;

"."{DIGIT}+(("lf"|"LF")?|("f"|"F")?)    return FLOAT;


{DIGIT}+("e"|"E")("-"|"+")?{DIGIT}+(("lf"|"LF")?|("f"|"F")?)     return FLOAT; 

{DIGIT}*"."{DIGIT}+("e"|"E")("-"|"+")*{DIGIT}+(("lf"|"LF")?|("f"|"F")?)  return FLOAT; 

"0x"({DIGIT}|{HEX})+([u|U])?    return INT;  // Hexadecimal number, suffix u or U
"0X"({DIGIT}|{HEX})+([u|U])?    return INT; // Hexadecimal number, suffix u or U
"0"+[0-7]+([u|U])?  return INT; // Octal number
{DIGIT}+([u|U])?    return INT; //Decimal number, suffix u or U

rt_Camera return RTCAMERA;
rt_Primitive return RTPRIMITIVE;
rt_Texture return RTTEXTURE;
rt_Material return RTMATERIAL;
rt_Light  return RTLIGHT;

"rt_"{ID}  {yylval = strdup(yytext); return STATE;} // Change for test8, otherwise keeps returen STATE with a semicolon after it! Don't know why

public return PUBLIC;
class return CLASS;
if return IF;
else return ELSE;
void return VOID;
int return INTNAME;
float return FLOATNAME;
bool return BOOLNAME;
return return RETURN;
color return COLOR; // TEST 5


const|break|case|continue|default|double|enum|extern|goto|sizeof|static|struct|switsch|typedef|union|unsigned|illuminance|ambient|dominantAxis|dot|hit|inside|inverse|luminance|max|min|normalize|perpendicularTO|pow|rand|reflect|sqrt|trace return KEYWORD;

for return FOR;
while return WHILE;
do return DO;

attribute|uniform|varying|const|private|scratch return QUALIFIER;

vec2|vec3|vec4|ivec2|ivec3|ivec4|bvec2|bvec3|bvec4 return TYPE;

{ID}    {yylval = strdup(yytext); return IDENTIFIER2;}    // modified for test 5; Add yytext for semantic check.   yylval.str_val = strdup(yytext)

"."   return SWIZZLE;

"/*"        {                                             //reference: http://web.mit.edu/gnu/doc/html/flex_2.html
            register int c;
            for ( ; ; )
              {
                while ( (c = input()) != '*' &&c != EOF )
                if (c == '\n') ++num_lines;  /* eat up text of comment */
            while ( c == '*' && (c =input()) != '/'&& c != EOF)
                if (c == '\n') ++num_lines;
        if ( c == '/' )
                break; /* found the end */
                if ( c == EOF )
                 {
                   printf( "ERROR(%d): EOF in comment",++num_lines);
               break;
                 }
              }
            }


[ \t\r]+  /* eat up itespace */   //add \r so linux can recognize the windows newline which end with \r

 "//"[^\n]*  /* 1 line comment */
     
.   {printf( "ERROR(%d): Unrecognized symbol \"%s\"\n", num_lines, yytext );} // Error report, num_lines should start from 1.


     
%%

int main(int argc, char **argv)
{
    //num_lines = 1; // To keep track of the current line number, num_lines starts with 1.
    if (argc > 1)
      yyin = fopen(argv[1], "r" );
    else
       yyin = stdin;
    //Call the parser (that will use yylex() internally)
    yyparse();
    //   printf( "# of lines = %d\n", num_lines);
    return 0;
}
